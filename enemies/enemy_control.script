go.property("health", 20)
go.property("damage", 1)
go.property("speed", 1)
go.property("zpos",0)

function init(self)
	--msg.post(".", "acquire_input_focus")
	self.last = vmath.vector3()
	self.lastSpeed = self.speed
	self.layer = 1
	self.visible = true
	--self.layer = 1
	msg.post("/map#path_manager", "get_start")
	self.tint = vmath.vector4()
	--msg.post("/enemy_factory#enemy_health", "createnode", {id = go.get_id()})
end

local function get_rotation(pos)
	return math.deg(math.atan2(pos.y - go.get_position().y, pos.x - go.get_position().x)-math.pi/2)
end

local function health_changed(self)
	local red = vmath.vector4()
	go.cancel_animations("#sprite")
	go.set("#sprite","tint.x",1)
	go.set("#sprite","tint.z",self.tint.z-0.5)
	go.set("#sprite","tint.y",self.tint.y-0.5)
	if self.health <= 0 then
		Die(self)
	else
		local easing = go.EASING_INOUTSINE
		go.animate("#sprite", "tint.x", go.PLAYBACK_ONCE_FORWARD, self.tint.x, easing, 0.3)
		go.animate("#sprite", "tint.z", go.PLAYBACK_ONCE_FORWARD, self.tint.z, easing, 0.3)
		go.animate("#sprite", "tint.y", go.PLAYBACK_ONCE_FORWARD, self.tint.y, easing, 0.3,0,function()
			go.animate("#sprite", "tint.x", go.PLAYBACK_LOOP_PINGPONG, 1, easing,(self.health/self.maxHealth)*2)
			go.animate("#sprite", "tint.z", go.PLAYBACK_LOOP_PINGPONG, self.tint.z-0.5, easing, (self.health/self.maxHealth)*2)
			go.animate("#sprite", "tint.y", go.PLAYBACK_LOOP_PINGPONG, self.tint.y-0.5, easing, (self.health/self.maxHealth)*2)
		end)
	end
end

local function move_char(self,pos,tile)
	pos = vmath.vector3(pos.x,pos.y,self.zpos+(0.5*(self.layer-1)))

	-- speed math
	self.last = go.get_position()
	local speed = self.speed
	if tile == 7 then speed = speed * 1.5
	elseif tile == 8 then speed = speed * 0.5 end
	go.set("#sprite", "playback_rate", self.lastSpeed)
	--//--

	--invisible blocks
	
	if not self.visible then
		go.set("#sprite","tint.w",0) 
	else
		go.set("#sprite","tint.w",1) 
	end
	if tile == 4 then 
		self.visible = not self.visible
	end
	--//--
	-- angle math
	local char_angle = go.get(".","euler.z")
	local angle = get_rotation(pos)
	if tile == 5 then go.set(".","euler.z",angle)
	elseif angle ~= char_angle then
		if math.abs(angle-char_angle) == 270 then 
			go.set(".","euler.z",char_angle+360)
		end
		go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, angle, go.EASING_LINEAR, 1/self.lastSpeed)
	end
	--//--

	-- layer stuff
	if tile == 2 then
		self.layer = self.layer + 1
	elseif tile == 3 then
		self.layer = self.layer - 1
	end
	--print(self.layer)
	--//--

	-- animate!
	go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_LINEAR, 1/self.lastSpeed, 0, function()
		if tile == 6 then go.delete() return end
		self.lastSpeed = speed
		msg.post("/map#path_manager", "get_next",{pos = go.get_position(),last = self.last,layer = self.layer})
	end)
	--//--
end


function on_message(self, message_id, message, sender)
	if message_id == hash("start_callback") then
		self.maxHealth = self.health
		self.tint = go.get("#sprite","tint")
		go.set_position(message.pos)
		self.last = message.pos
		self.lastSpeed = self.speed
		move_char(self, message.next, 5)
		msg.post("/map#path_manager", "get_next",{pos = go.get_position(),last = vmath.vector3(0,0,0),layer = self.layer})
	elseif message_id == hash("next_callback") then
		move_char(self,message.pos,message.tile)
	end
end

function Die(self)
	go.delete()
	particlefx.play("#death")
	particlefx.set_constant("#death", "emitter", "tint", self.tint)
end

function on_input(self, action_id, action)
	if action_id == hash("click") and action.pressed then
		local position = go.get_position()
		local dist = vmath.length(vmath.vector3(action.x,action.y,0)-position)
		if dist < 40 then
			self.health = self.health - 7
			health_changed(self)
		end

	end
end
function final(self) 
	--msg.post("/enemy_factory#enemy_health", "deletenode", {id = go.get_id()})
	self.health = 0
	health_changed(self)
end

--[[function update(self, dt)
	msg.post("/enemy_factory#enemy_health", "updatenode",
		{ id = go.get_id(), position = go.get_position(), hp = self.health/self.maxHealth,visible = self.visible})
end]]

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
