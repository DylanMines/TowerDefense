

local enemies = {}; --Enemy table

--Setting up enemy types
--TODO: change to the new ship thingy
local types = {};
local function add_type(speed,health,damage,name)
	table.insert(types, {speed = speed,health = health,damage = damage,name = name})
end
add_type(3.5, 45, 30, "Regular") --1: normal
add_type(5, 40, 26, "Fast") --2: slightly faster
add_type(3, 50, 35, "Damage") --3: bigger guns

----

local currentz = 0.24 --variable used to make sure enemies dont clip

--Enemy class--
local Enemy = {health = 1, damage = 1, zpos = 0, speed = 1,last = vmath.vector3(),layer = 1,visible = true, tint = vmath.vector4()}
function Enemy:new(o,type) --Constructor
	o = o or {}   -- create object
	setmetatable(o, self)
	self.__index = self

	if currentz <= 0 then currentz = 0.24 end 
	currentz = currentz-0.01

	--class is ready
	o.go = factory.create("#factory")
	--print(self.go)
	local current_type = types[type]
	o.name = current_type.name
	local sprite_url = msg.url("main",o.go,"sprite")
	go.set(sprite_url, "playback_rate", current_type.speed)
	msg.post(sprite_url, "play_animation",{id = hash(o.name.."_Enemy")})

	o.zpos = currentz
	o.last = vmath.vector3()
	o.damage = current_type.damage
	o.health = current_type.health
	o.maxHealth = o.health
	o.speed = current_type.speed
	o.lastSpeed = o.speed
	o.layer = 1
	o.visible = true
	msg.post("/map#path_manager", "get_start",{id = o.go})
	return o
end

function Enemy:get_rotation(pos) --accessor function to get rotation
	return math.deg(math.atan2(pos.y - go.get_position(self.go).y, pos.x - go.get_position(self.go).x)-math.pi/2)
end

function Enemy:get_position() -- accessor function to get position
	return go.get_position(self.go)
end

function Enemy:move(pos,tile) --Move the enemy from current position to pos while doing the action of tile
	pos = vmath.vector3(pos.x,pos.y,self.zpos+(0.5*(self.layer-1)))
	--print(tile)
	--print(self.lastSpeed)
	-- speed math
	self.last = go.get_position(self.go)
	local speed = self.speed
	if tile == 7 then speed = speed * 3
	elseif tile == 8 then speed = speed * 0.125 end
	local sprite_url = msg.url("main",self.go,"sprite")
	go.set(sprite_url, "playback_rate", self.lastSpeed)
	--//--

	--invisible blocks
	
	if not self.visible then
		go.set(sprite_url,"tint.w",0) 
	else
		go.set(sprite_url,"tint.w",1) 
	end
	if tile == 4 then 
		self.visible = not self.visible
	end
	--//--
	-- angle math
	local char_angle = go.get(self.go,"euler.z")
	local angle = self:get_rotation(pos)
	if tile == 5 then go.set(self.go,"euler.z",angle)
	elseif angle ~= char_angle then
		if math.abs(angle-char_angle) == 270 then 
			go.set(self.go,"euler.z",char_angle+360)
		end
		go.animate(self.go, "euler.z", go.PLAYBACK_ONCE_FORWARD, angle, go.EASING_LINEAR, 1/self.lastSpeed)
	end
	--//--

	-- layer stuff
	if tile == 2 then
		self.layer = self.layer + 1
	elseif tile == 3 then
		self.layer = self.layer - 1
	end
	--print(self.layer)
	--//--

	-- animate!
	go.animate(self.go, "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_LINEAR, 1/self.lastSpeed, 0, function()
		if tile == 6 then self:final() return end
		self.lastSpeed = speed
		msg.post("/map#path_manager", "get_next",{pos = go.get_position(self.go),last = self.last,layer = self.layer,id = self.go})
	end)
end

function Enemy:take_damage(dmg) --Take damage
	self.health = self.health - dmg
	self:health_changed()
end

function Enemy:health_changed() --Do the red flashing thingy (Not to be used outside of class but idk how to make private functions in lua)
	local red = vmath.vector4()
	local sprite_url = msg.url("main",self.go,"sprite")
	
	go.cancel_animations(sprite_url)
	go.set(sprite_url,"tint.x",1)
	go.set(sprite_url,"tint.z",0)
	go.set(sprite_url,"tint.y",0)
	if self.health <= 0 then
		self:final()
	else
		local easing = go.EASING_INOUTSINE
		local function animate_tint(x,y,z,time, pingpong ,callback)
			local playback = pingpong and go.PLAYBACK_LOOP_PINGPONG or go.PLAYBACK_ONCE_FORWARD
			go.animate(sprite_url, "tint.x", playback, x, easing, time)
			go.animate(sprite_url, "tint.z", playback, z, easing, time)
			if callback then 
				go.animate(sprite_url, "tint.y", playback, y, easing, time,0,callback)
			else 
				go.animate(sprite_url, "tint.y", playback, y, easing, time,0)
			end
		end
		animate_tint(self.tint.x, self.tint.y, self.tint.z, 0.3, false, function ()
			animate_tint(1, self.tint.y-0.5, self.tint.z-0.5, (self.health/self.maxHealth)*2, true)
		end)
	end
end

function Enemy:final() --Enemy died
	local particle_url = msg.url("main",self.go,"death")
	self.health = 0
	local size = 80
	local SM = size/5 --size multiplier
	enemies[self.go] = nil
		go.delete(self.go)
		particlefx.play(particle_url)
		particlefx.set_constant(particle_url, "emitter", "tint", vmath.vector4(1,1,1,1))
	for _,v in pairs(enemies) do
		if v == nil then return end
		local position = v:get_position()
		local selfPos = self:get_position()
		local dist = vmath.length(vmath.vector3(selfPos.x,selfPos.y,0)-position)
		if dist < size then
			local dmg = math.abs((size+SM)/math.sqrt(dist+SM)-math.sqrt(size+SM))
			print(dist,dmg*SM)
			v:take_damage(dmg*SM)
		end
	end
end

function Enemy:get_id() --Accessor function
	return self.go
end

function Enemy:start(pos,next) --Enemy just spawned
	go.set_position(pos,self.go)
	self.last = pos
	self.lastSpeed = self.speed
	self:move(next, 5)
	msg.post("/map#path_manager", "get_next",{pos = go.get_position(self.go),last = pos,layer = self.layer,id = self.go})
end

--end enemy class--

function SpawnEnemy(type)
	local newEnemy = Enemy:new(nil,type)
	enemies[newEnemy:get_id()] = newEnemy
end

function init(self)
	msg.post(".","acquire_input_focus")
	msg.post("@render:", "use_fixed_fit_projection")
	local function call_every_second(self, handle, time_elapsed)
		self.counter = self.counter + 1
		SpawnEnemy(math.random(3))
		--print(enemies[newEnemy:get_id()])
		if self.counter == 50000 then
		  timer.cancel(handle) -- cancel timer after 10 calls
		end
	  end
	self.counter = 0
	--SpawnEnemy(1)
	timer.delay(0.1, true, call_every_second)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("start_callback") then --TODO: figure out which enemy to mov
		--print(message.id)
		local enemy = enemies[message.id]
		--print("starting at "..message.pos)
		enemy:start(message.pos,message.next)
	elseif message_id == hash("next_callback") then
		local enemy = enemies[message.id]
		--print(message.id)
		--print("going to next at "..message.pos)
		enemy:move(message.pos,message.tile)
		--move_char(self,message.pos,message.tile)
	elseif message_id == hash("take_damage") then
		local enemy = enemies[message.id]
		enemy:take_damage(message.damage)
	end
end

function on_input(self,action_id,action)
	if action_id == hash("click") and action.pressed then
		for _,v in pairs(enemies) do
			if v == nil then return end
			local position = v:get_position()
			local dist = vmath.length(vmath.vector3(action.x,action.y,0)-position)
			if dist < 20 then
				v:final()
			end
		end
	elseif action_id == hash("killall") then
		for _,v in pairs(enemies) do
			if v == nil then return end
			v:take_damage(70)
		end
	end
end